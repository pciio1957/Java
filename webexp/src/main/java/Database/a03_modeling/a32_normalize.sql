
/*

#정규화
1. 목표 
	1) 정규화의 필요성과 이상 현상의 의미를 이해한다.
	2) 정규화를 수행하기 위해 함수 종속성의 개념을 이해한다
	3) 정규형의 유형과 관계를 이해하고 실제 예를 통해 정규화 과정을 진행할 수 있다.
	
2. 목차
	1) 이상현상에 대한 이해
	2) 함수 종속성 개념
	3) 정규화 과정
		제 1 정규형
		제 2 정규형
		제 3 정규형
		보이스/코드 정규형
		제 4 정규형
		제 5 정규형
		
3. 이상현상
	1) 이상 현상
		불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입, 수정, 삭제 연산을 
		수행할 때 발생할 수 있는 부작용을 말함
		
	2) 정규화 과정
		이러한 이상 현상을 제거하면서 데이터베이스를 무결성있게 설계해 나가는 과정을 말함
		
4. 이상현상의 종류
	1) 삽입 이상 : 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
	2) 갱신 이상 : 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 문제
	3) 삭제 이상 : 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실 문제 
	
5. 함수 종속성
	1) 속성들 간의 관련성
		ex) 컬럼 간의 관련성을 의미 
		cf) 정규화에서는 함수적 종속성을 이용하여 릴레이션(테이블)을 연관선이 있는
		속성(컬럼)들만 구성되도록 분해하여 이상 현상이 발생하지 않는(무결성있는 데이터) 
		올바른 릴레이션(테이블)로 만들어나가는 과정이다
	
	2) 함수 종속
		X가 Y를 함수적으로 결정한다
		= X -> Y로 표현(X는 결정자, Y는 종속자)
		보통 X를 테이블의 key로 만들고, Y는 그 구성요소를 뜻함
			ex) 사원번호 -> (사원명, 직책, 입사일, 급여, 보너스)
			사원번호 -> 사원명, 사원번호 -> 직책
	
	3) 함수 종속 관계 판단시 유의 사항
		속성 자체의 특성과 의미를 기반으로 함수 종속성을 판단해야 함
		- 속성 값은 계속 변할 수 있으므로 현재 릴레이션(테이블)에 포함된
		속성(컬럼)의 값만으로 판단하면 안됨
		- 일반적으로 기본키(사원번호)와 후보키(주민번호)는 릴레이션(테이블)의 
		다른 모든 속성 
		
	4) 완전 함수 종속
		릴레이션(테이블)에서 속성집합(컬럼1의 데이터) Y가 속성집합(컬럼2의 데이터) X에
		함수적으로 종속되어 있지만 속성집합 X(컬럼2의 데이터)의 전체가 아닌 일부분에는
		종속되지 않음을 의미
		일반적으로 함수 종속은 완전 함수 종속을 의미한다
		ex) 당첨여부는 키(고객아이디, 이벤트번호)에 완전 함수 종속됨 
		
	5) 부분 함수 종속
		릴레이션(테이블)에서 속성집합(컬럼1의 데이터) Y가 속성집합(컬럼2의 데이터) X의
		전체가 아닌 일부분에서 함수적으로 종속됨을 의미
		ex) 고객이름은 (고객아이디, 이벤트번호)에 부분 함수 종속된다.
		
		- 고객아이디 -> 고객이름 : 고객이름은 고객아이디에 완전 종속적 
			(고객아이디, 이벤트번호) -> 당첨여부 : 당첨여부는 고객아이디와 이벤트번호(복합키)에 완전 종속
			(고객아이디, 이벤트번호) -> 고객이름	: 고객이름은 고객아이디와 이벤트번호(복합키)에 부분 종속

	
6. 정규화
	1) 개념 : 
		함수 종속성을 이용해 릴레이션(테이블)을 연관성이 있는 속성들로만 구성되도록
		분해해서, 이상 현상이 발생하지 않는 올바른 릴레이션(테이블)로 만들어 가는 과정
		- 기본 목표 : 관련이 없는 함수 종속성(부분 함수 종속 포함)은 별개의 릴레이션으로 표현
		
	2) 주의사항 
		정규화를 통해 릴레이션(테이블)은 무손실 분해되어야 한다
		- 릴레이션의 의미상 동등한 릴레이션들로 분해되어야 하고, 분해로 인한 정보 손실이
		발생하지 않아야함 
		- 분해된 릴레이션들을 자연조인(where 분해 후 테이블.컬럼 = 분해 후 테이블.컬럼)
		실행하면 분해 전의 릴레이션(테이블)로 복원이 가능해야함 
		
	3) 정규화 (NF:normal form)
		릴레이션(테이블)이 정규화(분해)된 정도
		각 정규형마다 제약조건이 존재
			- 정규형의 차수가 높아질수록 요구되는 제약조건이 많아지고 엄격해짐
		릴레이션(테이블)의 특성을 고려해서 적합한 정규형으로 나아간다
	
	4) 정규화 과정
		기본 정규형 = 제 1정규형, 제 2정규형, 제 3정규형, 보이스/코드 정규형(BCNF)
		고급 정규형 = 제 4정규형, 제 5정규형
		상위 정규가 끝나야 하위 정규화 과정을 진행할 수 있다.
		
		제 1정규형 > 제 2정규형 > 제 3정규형 > 보이스/코드 정규형(BCNF) > 제 4정규형 > 제 5정규형
		
		
7. 제 1정규형
8. 제 2정규형
9. 제 3정규형
	1) 이행적 함수 종속성
		릴레이션(테이블)을 구성하는 3개의 속성(컬럼) 집합 X, Y, Z에 대해 함수 종속 
		관계가 X->Y, Y-> Z가 존재하면 논리적으로 X->Z가 성립되는데 
		이때 Z가 X에 이행적으로 함수 종속되었다고 함 
		
	2) 개념
		릴레이션(테이블)이 제 2정규형에 속하고, 기본키가 아닌 모든 속성이 기본 키에
		이행적 함수 종속이 되지 않으면 제 3정규형을 만족함
		제 2정규형에 속하는 릴레이션(테이블)이 제 3정규형을 만족하게 하려면
			- 모든 속성이 기본키에 이행적 함수 종속이 되지 않도록 분해
			
			
10. 보이스/코드 정규형(BCNF:Boyce/codd Normal Form)
	1) 필요성
    	하나의 릴레이션(테이블)에 여러개의 후보키 (사원테이블에 주민번호, 복합된 후보키)가 
    	존재하는 경우, 제3정규형까지 모두 만족해도 이상 현상이 발생할 수 있다. 
    	
    	
11. 제 4정규형
	릴레이션이 보이스/코드 정규형을 만족하면서
	함수 종속이 아닌 다치 종속(MVD:multi valued Dependency)를 제거하면 속하게됨
	
12. 제 5정규형
	모든 릴레이션이 제 5정구형에 속해야만 바람직한 것은 아님
	일반적으로 제 3정규형이나 보이스/코드 정규형에 속하도록 
	릴레이션을 분해하여 데이터 중복을 줄이고 이상 현상을 해결하는 경우가 많음 
	
	
*** 결국, 정규화 규칙은 원자성이라는 개념에 의해서 원인에 대한 분석으로
	1~5정규화 및 보이스코드 정규화를 처리하고 식별자와 비식별자를 통해 
	효과적으로 이상현상(삽입/삭제/수정)이 발생하지 않도록 테이블을 
	분해시켜가는 과정으로 진행하면 된다 
*
*/



-- 
CREATE TABLE normal_exp02 (
	cu_id varchar2(50),
	grade varchar2(10),
	discount number
);

INSERT INTO normal_exp03 values('apple', 'gold', 0.1);
INSERT INTO normal_exp03 values('banana', 'vip', 0.2);
INSERT INTO normal_exp03 values('carrot', 'gold', 0.1);
INSERT INTO normal_exp03 values('orange', 'sliver', 0.05);

SELECT * FROM normal_exp03;

CREATE TABLE normal_exp03_1
AS SELECT cu_id, grade FROM normal_exp3;

CREATE TABLE normal_exp03_2
AS SELECT distinct grade, discount FROM normal_exp3;


-- 응용) 위 테이블과 데이터는 3정규화 처리하여 erd와 sql 코드 처리하기 (1조)

CREATE TABLE normal_order03 (
	ordno char(5),
	isexport char(2),
	priority number
);



CREATE TABLE normal_user03 (
	usrno NUMBER,
	busno NUMBER,
	ordno char(5)
);

-- 위에와 다른 풀이  
-- 주문 : ordno, usrno 
--		주문번호, 고객번호(FK)
-- 고객 : distinct usrno, busno, priority, (isexport)
--		고객번호, 수출여부, 사업자번호, 고객우선순위
-- 이 외에 제품, 주문목록이 더 있음!

INSERT INTO normal_order03 values('AB345', 'X', 1);
INSERT INTO normal_order03 values('AD347', 'Y', 3);
INSERT INTO normal_order03 values('CA210', 'X', 8);
INSERT INTO normal_order03 values('CB230', 'X', 3);
INSERT INTO normal_order03 values('AV231', 'Y', 2);


INSERT INTO normal_user03 values(4520, 398201, 'AB345');
INSERT INTO normal_user03 values(2341, null, 'AD347');
INSERT INTO normal_user03 values(3280, 398201, 'CA210');
INSERT INTO normal_user03 values(8320, 398201, 'AB231');



/*

#관계 설정
1. 식별자 관계 
	참조하는 테이블의 키를 현재 테이블에 키로 같이 사용할 때
	ex) 고객이 물건 하나의 주문을 사용할 때
	컬럼을 최소로 사용할 수 있지만, 테이블간에 연관관계가 많을 때
	복합키를 많이 만들어야 하기 때문에 복잡성이 높아지는 경우가 많다
	
2. 비식별자 관계
	참조하는 테이블의 키를 현재 테이블의 키로 사용하지 않을 때
	ex) emp-dept 관계
	복잡성이 많은 테이블 연관관계는 보다 효과적으로 테이블 관계를
	정리할 수 있는 특징이 있다 
	
*/


-- 제 3정규화
CREATE TABLE normalForm3 (
	cus_id varchar2(50),
	ilesson varchar2(50),
	tech_id varchar2(50)
);

INSERT INTO normalForm3 values('apple', '영어회화', 'P001');
INSERT INTO normalForm3 values('banana', '기초토익', 'P002');
INSERT INTO normalForm3 values('carrot', '영어회화', 'P001');
INSERT INTO normalForm3 values('carrot', '기초토익', 'P004');
INSERT INTO normalForm3 values('orange', '영어회화', 'P003');
INSERT INTO normalForm3 values('orange', '기초토익', 'P004');

SELECT * FROM normalForm3;


-- 응용) 보이스코드 정규화 처리 후 제출 (2조) ~ 16:10분
-- 1) 인터넷강좌신청 테이블 : 고객id, 인터넷강좌, 담당강사번호 -> 보이스코드 처리
-- 2) 고객정보 : 고객id, 인터넷강좌명
-- 	  강좌정보 : 인터넷강좌, 담당강사번호

-- 고객정보 테이블 : 고객의 정보
CREATE TABLE normal_customer04 
AS SELECT cus_id, teah_id FROM normalform3;

-- 강좌정보 테이블 : 인터넷 강좌의 정보
CREATE TABLE normal_lesson04
AS SELECT DISTINCT teah_id, ilesson FROM normalform3;